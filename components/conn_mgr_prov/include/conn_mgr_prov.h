/* Unified Provisioning Example

   This example code is in the Public Domain (or CC0 licensed, at your option.)

   Unless required by applicable law or agreed to in writing, this
   software is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
   CONDITIONS OF ANY KIND, either express or implied.
*/

#pragma once

#include <esp_event_loop.h>
#include <protocomm.h>

/**
 * @brief   Structure for specifying the provisioning scheme to be 
 *          followed by the manager
 *
 * @note    Ready to use schemes are available:
 *              - conn_mgr_prov_scheme_ble    : for provisioning over BLE transport + GATT server
 *              - conn_mgr_prov_scheme_softap : for provisioning over SoftAP transport + HTTP server
 */
typedef struct conn_mgr_prov_scheme {
    /**
     * Function which is to be called by the manager when it is to
     * start the provisioning service associated with a protocomm instance
     * and a scheme specific configuration
     */
    esp_err_t (*prov_start) (protocomm_t *pc, void *config);

    /**
     * Function which is to be called by the manager to stop the
     * provisioning service previously associated with a protocomm instance
     */
    esp_err_t (*prov_stop) (protocomm_t *pc);

    /**
     * Function which is to be called by the manager to generate
     * a new configuration for the provisioning service, that is
     * to be passed to prov_start()
     */
    void *(*new_config) (void);

    /**
     * Function which is to be called by the manager to delete a
     * configuration generated using new_config()
     */
    void (*delete_config) (void *config);

    /**
     * Function which is to be called by the manager to set the
     * service name and key values in the configuration structure
     */
    esp_err_t (*set_config_service) (void *config, const char *service_name, const char *service_key);

    /**
     * Function which is to be called by the manager to set a protocomm endpoint
     * with an identifying name and UUID in the configuration structure
     */
    esp_err_t (*set_config_endpoint) (void *config, const char *endpoint_name, uint16_t uuid);

    /**
     * Mode of operation of WiFi while provisioning service is active
     */
    int wifi_mode;
} conn_mgr_prov_scheme_t;

/**
 * @brief   Events generated by conn_mgr_prov
 */
typedef enum {
    CMP_ENDPOINT_CONFIG,
    CMP_ENDPOINT_ADD,
    CMP_ENDPOINT_REMOVE,
    CMP_PROV_START,
    CMP_PROV_END,
    CMP_INIT,
    CMP_DEINIT,
} conn_mgr_prov_cb_event_t;

typedef esp_err_t (*conn_mgr_prov_cb_func_t)(void *user_data, conn_mgr_prov_cb_event_t event);

/**
 * @brief   Event handler that is used by the manager while
 *          provisioning service is active
 */
typedef struct {
    conn_mgr_prov_cb_func_t event_cb;
    void *user_data;
} conn_mgr_prov_event_handler_t;

/* Event handler can be set to none if not used */
#define CMP_EVENT_HANDLER_NONE { \
    .event_cb  = NULL,   \
    .user_data = NULL    \
}

/**
 * @brief   Structure for specifying the manager configuration
 */
typedef struct {
    /**
     * Provisioning scheme to use. Following schemes are already available:
     *     - conn_mgr_prov_scheme_ble    : for provisioning over BLE transport + GATT server
     *     - conn_mgr_prov_scheme_softap : for provisioning over SoftAP transport + HTTP server
     */
    conn_mgr_prov_scheme_t scheme;

    /**
     * Event handler required by the scheme for incorporating scheme specific
     * behavior while provisioning manager is running. Various options may be
     * provided by the scheme for setting this field. Use CMP_EVENT_HANDLER_NONE
     * when not used. When using scheme conn_mgr_prov_scheme_ble, the following
     * options are available:
     *     - CMP_SCHEME_BLE_EVENT_HANDLER_FREE_BTDM
     *     - CMP_SCHEME_BLE_EVENT_HANDLER_FREE_BLE
     *     - CMP_SCHEME_BLE_EVENT_HANDLER_FREE_BT
     */
    conn_mgr_prov_event_handler_t scheme_event_handler;

    /**
     * Event handler that can be set for the purpose of incorporating application
     * specific behavior. Use CMP_EVENT_HANDLER_NONE when not used.
     */
    conn_mgr_prov_event_handler_t app_event_handler;
} conn_mgr_prov_config_t;

/**
 * @brief   Initialize provisioning manager instance
 *
 * @param[in] config Configuration structure
 *
 * @return
 *  - ESP_OK      : Success
 *  - ESP_FAIL    : Fail
 */
esp_err_t conn_mgr_prov_init(conn_mgr_prov_config_t config);

/**
 * @brief   Wait for provisioning service to finish(if started)
 */
void conn_mgr_prov_wait(void);

/**
 * @brief   Stop provisioning (if running) and release
 *          resource used by the manager
 */
void conn_mgr_prov_deinit(void);

/**
 * @brief   Checks if device is provisioned
 * *
 * @param[out] provisioned  True if provisioned, else false
 *
 * @return
 *  - ESP_OK      : Retrieved provision state successfully
 *  - ESP_FAIL    : Failed to retrieve provision state
 */
esp_err_t conn_mgr_prov_is_provisioned(bool *provisioned);

/**
 * @brief   Start provisioning
 *
 * @param[in] security      Security mode
 * @param[in] pop           Pointer to proof of possession (NULL if not needed)
 * @param[in] service_name  Unique name of the service. This translates to:
 *                              - WiFi SSID when provisioning mode is softAP
 *                              - Device name when provisioning mode is BLE
 * @param[in] service_key   Key required by client to access the service (NULL if not needed).
 *                          This translates to:
 *                              - WiFi password when provisioning mode is softAP
 *                              - ignored when provisioning mode is BLE
 *
 * @return
 *  - ESP_OK      : Provisioning started successfully
 *  - ESP_FAIL    : Failed to start
 */
esp_err_t conn_mgr_prov_start_provisioning(int security, const char *pop,
                                           const char *service_name, const char *service_key);

/**
 * @brief   Stop provisioning (if running)
 */
void conn_mgr_prov_stop_provisioning(void);

/**
 * @brief   Configure an extra endpoint
 *
 * This API can be called by the application if it wants to configure an extra endpoint. The
 * API must be called when the application gets the callback with event CMP_ENDPOINT_CONFIG.
 *
 * @param[in] ep_name  Name of the endpoint
 *
 * @return
 *  - ESP_OK      : Success
 *  - ESP_FAIL    : Failure
 */
esp_err_t conn_mgr_prov_endpoint_configure(const char *ep_name);

/**
 * @brief   Add a configured endpoint
 *
 * This API can be called by the application if it wants to add i.e. enable the endpoint. The
 * API must be called when the application gets the callback with event CMP_ENDPOINT_ADD.
 *
 * @param[in] ep_name   Name of the endpoint
 * @param[in] handler   Endpoint handler function
 * @param[in] user_ctx  User data
 *
 * @return
 *  - ESP_OK      : Success
 *  - ESP_FAIL    : Failure
 */
esp_err_t conn_mgr_prov_endpoint_add(const char *ep_name, protocomm_req_handler_t handler, void *user_ctx);

/**
 * @brief   Remove an endpoint
 *
 * This API can be called if the application wants to selectively remove an endpoint while the
 * provisioning is still in progress.
 * All the endpoints are removed automatically when the provisioning stops.
 *
 * @param[in] ep_name  Name of the endpoint
 */
void conn_mgr_prov_endpoint_remove(const char *ep_name);

/**
 * @brief   Event handler for provisioning app
 *
 * This is called from the main event handler and controls the
 * provisioning application, depending on WiFi events
 *
 * @param[in] ctx   Event context data
 * @param[in] event Event info
 *
 * @return
 *  - ESP_OK       : Event handled successfully
 *  - ESP_ERR_FAIL : This event cannot be handled
 */
esp_err_t conn_mgr_prov_event_handler(void *ctx, system_event_t *event);
